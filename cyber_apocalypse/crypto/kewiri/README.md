# Kewiri

Подготовлено:`rasti`

Автор задания:`rasti`

Уровень сложности: Очень легко

## Описание 
- Великие учёные Элдории подготовили серию испытаний, каждое из которых проверит глубину вашего понимания древних математических искусств. Тем, кто ответит мудро, будет даровано прозрение, а недостойные будут низвергнуты в пучину невежества. Примите ли вы вызов, или ваш разум дрогнет под тяжестью забытых знаний?

## Вопрос 1

При подключении к экземпляру мы ждём несколько секунд, пока инициализируется среда, а затем нам задают первый вопрос. Оказывается, у нас есть всего две секунды, чтобы ответить на каждый вопрос, иначе мы получим Too slow...


```txt
[!] The ancient texts are being prepared...
You have entered the Grand Archives of Eldoria! The scholars shall test your wisdom. Answer their questions to prove your worth and claim the hidden knowledge.
You are given the sacred prime: p = 21214334341047589034959795830530169972304000967355896041112297190770972306665257150126981587914335537556050020788061
[1] How many bits is the prime p? >
```

```txt
[!] Древние тексты готовятся... Вы вошли в Великие Архивы Эльдории! Ученые будут испытывать вашу мудрость. Ответьте на их вопросы, чтобы доказать свою ценность и получить скрытое знание.
Вам вручается священное простое число: p = 21214334341047589034959795830530169972304000967355896041112297190770972306665257150126981587914335537556050020788061
[1] Насколько много бит в простом числе p? >
```

## Решение 1 

Открываем оболочку python и используем метод bit_length()
```python
p = 21214334341047589034959795830530169972304000967355896041112297190770972306665257150126981587914335537556050020788061
print(p.bit_length())
```

## Вопрос 2

```txt
...
[2] Enter the full factorization of finite field F_p in ascending order of factors (format: p0,e0_p1,e1_ ..., where pi are the distinct factors and ei the multiplicities of each factor) 
```
```txt
[2] Введите полную факторизацию мультипликативной группы конечного поля F_p в порядке возрастания множителей (формат: p0,e0_p1,e1_ ..., где pi — различные простые множители, а ei — кратности каждого множителя) >
```


## Решение 2

Чтобы ответить на это, можно использовать [SageMath](https://doc.sagemath.org/html/ru/tutorial/index.html) или любой онлайн‑сервис факторизации, например factordb. В этом пояснении мы покажем SageMath в образовательных целях. В Sage определённое конечное поле задаётся конструктором `GF`. Важный факт: порядок мультипликативной группы конечного поля над простым p равен p-1. Следовательно, задача сводится к факторизации p-1. GF это класс конечного поля над p.

```python
F = GF(p)
print(factor(p-1))
```

## Вопрос 3

```txt
[3] Для этого вопроса нужно отправить 1, если элемент является генератором конечного поля F_p, иначе 0. >
```

## Решение 3

Похоже на задачу поиска решения. Нам будут даны несколько целых чисел, и требуется определить, являются ли они генераторами, за ограниченное время.

Отныне мы будем ссылаться только на мультипликативную группу конечного поля F_p. Следовательно, операция в группе — умножение, а не сложение.

Напомним, что генератор g ∈ F_p — это элемент порядка p-1; то есть наименьшее целое k такое, что g^k ≡ 1, равно p-1. Проще говоря, последовательными возведениями в степени он порождает всю группу. Существуют разные подходы; наивный — перечислять все степени g^1, g^2, ..., g^k до появления 1. Но для столь больших p это практически невыполнимо, поэтому нужен оптимизированный метод. Здесь полезна теорема Лагранжа. Она гласит:

> Пусть G — группа и a ∈ G. Порядок элемента a делит порядок группы G.

Ответы, такие как [1] и [2], показывают, как можно использовать эту теорему для проверки, является ли элемент генератором. Основная сложность — факторизация p-1, которую мы уже знаем из вопроса (2).

Следовательно, можно записать следующий метод проверки, является ли элемент g генератором поля 
```math
\forall f \in \text{простые множители}(p-1): 
\left(g^{\frac{p-1}{f}} \mod p \neq 1 \text{ или } f = p-1\right)
```

```python
def is_generator(g):
		p_1_factors = list(factor(p-1))
    for f,_ in p_1_factors:
      	# игнорируем мультипликативность
        # важны только простые множители 
        if pow(g, (p-1)//f, p) == 1 and f != p-1:
            # g является генератором поля 
            return False
		return True
```

## Вопрос 4

## Решение 4

## Вопрос 5

## Решение 5

## Вопрос 6

## Решение 6